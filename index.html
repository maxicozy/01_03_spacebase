<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SPACE INVADERS</title>
  <style>
  	pre {
	  position: absolute;
	  left: 50%;
	  top: 50%;
	  -webkit-transform: translate(-50%, -50%);
	  transform: translate(-50%, -50%);
	  border: 1px solid gray;
	}

	body {
		color: white;
		background-color: black;
	}
  </style>
</head>
<body>
  <pre id="console">
  	<!-- Hier landet später der Output aus Javascript -->
  </pre>

	<script src="classes.js"></script>
  <script>
	

		let startPosX = 0;
		let startPosY = 0;
		let invaders = [];
		const gameSpeed = 2;
		const invaderWidth = 8;
		const invaderHeight = 5;
    let renderStr = "";
    let rows = 50;
    let cols = 140;
    let cnt = 0;
    let spaceshipPos = Math.round(cols / 2);
    let currentBullets = [];
    let obstacles = [];
		let run = 0;
		let xoffset = 1;
		let yoffset = 1;
		let invaderDirection = 1;
		let invaderRow = [];
		let rowId = 0;

	/*
	*	SPIELELOGIK
	*/
	function newGame() {
		// let invaderRowSegment = generateInvader(invaderWidth, invaderHeight);
		// for (let i = 0; i < 5; i++) { {
		// 		invaders[i] = {};
		// 		invaders[i].Appearance = invaderRowSegment
		// 	}
		// }
		let newInvaderRow = new InvaderRow(startPosX, startPosY, invaderWidth, invaderHeight, InvaderRow.generateInvaderRow(invaderWidth, invaderHeight), rowId);
		invaders.push(newInvaderRow);

		console.log(invaders);

		//TODO Punktestände
		obstacles.push({x: Math.round(cols/2)-5, 
						y: rows-10, 
						width: 10,
						height:3,
						char: "◩" });
	}

	function fireBullet() {
		currentBullets.push({x: spaceshipPos+3, y: rows-4});
	}


	/*
	 *	HELFERFUNKTIONEN
	 */
	//Characters in String editieren

	//X/Y-Wert in fortlaufende String-Position umwandeln
	function xyToStringPos(posX, posY) {
		//Zusätzliche Characters wegen Zeilenumbrüchen
		let rowOffset = posY; 
		//Position im Gesamtstring, (AnzahlZeilen/YPos+i)*ZeichenProZeile plus rowOffset plus momentan gezeichnete Zeile des Ships
		let posInString = posY*cols+rowOffset+posX; 
		return posInString;
	}

	//Spieler-Interaktionen verschicken
	document.addEventListener('keydown', (event) => {
	  const keyCode = event.keyCode;	  

			if(keyCode === 37) {
				//Linke Pfeiltaste - Spaceship nach links bewegen
	  	spaceshipPos = Math.max(0, spaceshipPos-1);
	  } else if(keyCode === 39) {
	  	//Rechte Pfeiltaste - Spaceship nach rechts bewegen
	  	spaceshipPos = Math.min(cols-7, spaceshipPos+1);
	  } else if(keyCode === 32) {
	  	//Leertase - Feuer!
	  	fireBullet();
	  }
	}, false);


	/*
	* RENDERFUNKTIONEN
	*/
	function renderBackground(rows, cols) {
		//console.log("render "+cnt)
		let str = ""
		for (var i = 0; i < rows; i++) {
			for (var j = 0; j < cols; j++) {
				if(i == cnt + (Math.round(Math.random()*30)) * 2) str += "*"
				else str += " "
			}
			str += "\n";
		}
		cnt++;
		if(cnt * 5 > rows * 0.2) cnt = 0;
		return str;
	}

	function renderSpaceship(posX, posY) {
		//Spaceship-Array
		let spaceship = ["   ◊   ",
						 				 " ◞ ◌ ◟ ",
						 				 "◿▨▨▩▧▧◺",
						 				 "▨▨▨◍▧▧▧"]

		for (var i = 0; i < spaceship.length; i++) {			
			//Zeilenweise in String schreiben
			renderStr = Helper.setCharsAt(renderStr,xyToStringPos(posX, posY+i),spaceship[i]);
		}
	}

	function renderObstacles() {
		obstacles.forEach((obstacle) => {
			for (var i = 0; i < obstacle.height; i++) {			
				//Zeilenweise in String schreiben
				renderStr = Helper.setCharsAt(renderStr,xyToStringPos(obstacle.x, obstacle.y+i),obstacle.char.repeat(obstacle.width));
			}
		});
	}


	function renderBullets() {
		//TODO: Prüfen ob eine Kugel einen Invader oder ein Obstacle trifft, wenn ja Aktion auslösen

		//Kugeln entfernen die am oberen Rand angekommen sind ohne Treffer
		currentBullets = currentBullets.filter(bullet => bullet.y > 1);
		//Kugeln einen Schritt weiter bewegen, dann rendern
		currentBullets.forEach((bullet) => {
			bullet.y -= 1;
			renderStr = Helper.setCharsAt(renderStr,xyToStringPos(bullet.x, bullet.y),"|");
		})			
	}

	function renderInvaders(posX, posY, invaders) {
		for (let j = 0; j < invaders[rowId].invaders.length; j++) {
			for (let i = 0; i < invaders[rowId].invaders[j].appearance.length; i++) {
				renderStr = Helper.setCharsAt(renderStr,xyToStringPos(invaders[rowId].invaders[j].id + posX, posY+i), invaders[rowId].invaders[j].appearance[i]);		
			}
			posX =  posX + (cols/5 - invaderWidth*2) + invaderWidth + 1;
		}
	}

	//Hauptrenderfunktion
	function render() {
		run++
		if (run >= gameSpeed) {
			run = 0;
					if (xoffset == 0 || xoffset  ==  (cols/5 - invaderWidth*2) + 23) {
						yoffset++;
						invaderDirection = invaderDirection * (-1);
						xoffset = xoffset + invaderDirection;
					}
				else {
					xoffset = xoffset + invaderDirection;
				}
		}

		//Render Background
		renderStr = renderBackground(rows,cols);

		//Render Obstacle
		renderObstacles();

		renderSpaceship(spaceshipPos, rows-4, renderStr);

		//Render Invaders
		renderInvaders(startPosX + xoffset, startPosY + yoffset, invaders, renderStr);

		//Render Bullets
		renderBullets(renderStr);

		//Gesamtergebnis anzeigen
		document.getElementById("console").innerText = renderStr; 
	
	}

	//Es geht los - alle 40 Millisekunden rendern
	newGame();
	setInterval(render, 40);
  </script>
</body>
</html>